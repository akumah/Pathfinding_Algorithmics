# Directories to use
BIN = bin
OBJ = obj
DEPS = deps
SRC = src
INC = include

# Search paths for source, object and dependency files
vpath %.cpp $(SRC)
vpath %.o $(OBJ)
vpath %.d $(SRC)

#Set compiler
CXX=g++

# Set default compiler parameters
# -Wall 	shows all warnings when compiling, always use this!
# -std=c++11 	enables the C++11 standard mode
CXXFLAGS = -Wall -std=c++14

# Compiler flag -Idir specifies, that there are includes in the 'dir' directory
CXXFLAGS += -I$(INC)

# Linker flags (order the compiler to link with our library)
# LFLAGS += -Llib -lpath

# The name of the testing app
TESTAPP = $(BIN)/test_pathing.exe

# This is the first target. It will be built when you run 'make' or 'make build'
build: $(TESTAPP)
# Create the library by using 'ar'
#$(LIBRARY) : $(LIBOBJS)
#	ar cr $(LIBRARY) $(LIBOBJS)

# Compile each source file to obj file
%.o: %.cpp %.d | $(OBJ)
	$(CXX) $(CXXFLAGS) -c -o $(OBJ)/$@ $< $(CXXFLAGS)

# Create dependency makefiles (so that changing headers causes rebuild
%.d : %.cpp
	@echo $@ '\' > $@
	@$(CXX) -M $(CXXFLAGS) $< >> $@

sources := simple_mesh.cpp test_pathing.cpp
include $(sources:.cpp=.d)

# Link the app
$(TESTAPP): test_pathing.o | $(BIN)
	$(CXX) -o $@ $^ $(CXXFLAGS)

# Create folders, if necessary
$(BIN) $(DEPS) $(OBJ):
	mkdir $@

doc:
	doxygen

clean:
	rm -rf $(OBJ)
	rm -rf $(DEPS)
	rm -rf $(TESTAPP)
	rm -rf docs
